(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{182:function(t,n,s){"use strict";s.r(n);var e=s(0),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"从bind-throttle-debounce看this作用域问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#从bind-throttle-debounce看this作用域问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 从bind throttle debounce看this作用域问题")]),this._v(" "),n("p",[this._v("结合几个比较经典的api讲一下this作用域的问题。(先开个坑)")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("// eslint-disable-next-line\n// 陷阱1：如果 a = 1,没有用 var const let之类声明在浏览器环境下会被挂载在window对象的属性下\na = 1;\nconst test = function (callBack) {\n  this.a = 2;\n  return function () {\n    console.log(this);\n    callBack && callBack();\n  };\n};\nconst b = {\n  test: '',\n  a: '5',\n};\nb.test = test();\nb.test();\nfunction test2() { console.log(this.a); }\ntest2();\nfunction asdf() { console.log(this.a); }\nasdf();\n")])])])])}],!1,null,null,null);n.default=a.exports}}]);